<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
		<script type="text/javascript" src="d3.js"></script>
	</head>
	<body>
		<canvas></canvas>
		<br/>
		<textarea rows="15" cols="80">
		The transformation step is most important, as this is where the mapping happens. D3 provides a structure for applying these transformations, but, as we’ll see, you define the mapping rules. Should larger values make taller bars or brighter circles? Will clusters be sorted on the x-axis by age or category? What color palette is used to fill in countries on your world map? All of the visual design decisions are up to you. You provide the concept, you craft the rules, and D3 executes it—without telling you what to do. (Yes, it’s like the opposite of Excel’s pushy “Chart Wizard.”)
		</textarea>
		<button onclick="transition()">Update</button>
		<button onclick="sample()">Sample</button>
		<br/>
		<canvas></canvas>
	</body>
</html>

<script type="text/javascript">
var w = 1200;
var h = 800;
var _w = 500;
var _h = 500;
window.onload = function(){
	var canvas1 = document.getElementsByTagName("canvas")[0];
	canvas1.setAttribute("width", w);
	canvas1.setAttribute("height", h);
	var canvas2 = document.getElementsByTagName("canvas")[1];
	canvas2.setAttribute("width", _w);
	canvas2.setAttribute("height", _h);
}
function hasProperty(arr, name){
	for(var i = 0; i < arr.length; i++){
		if(arr[i].text === name)
			return i;
	}
	return -1;
}
function text2Words(str){
	var words =  str.replace(/[\s|\~|\`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\+|\=|\||\\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\“|\,|\”|‘\<|\.|\>|\/|\—|\?|\t|\n]+/g, " ").split(" ");
	if(words[0] == "")
		words.shift();
	if(words[words.length - 1] == "")
		words.pop();
	var res = [];
	for(var i = 0; i < words.length; i++){
		var id = hasProperty(res, words[i]);
		if(id >= 0){
			res[id].value++;
		}
		else{
			res.push({text:words[i], value:1});
		}
	}
	return res.sort(function(a,b){ return b.value - a.value; });
}
function draw(data){
	var canvas = document.getElementsByTagName("canvas")[0];
	var cxt = canvas.getContext("2d");
	cxt.clearRect(0,0,w,h);
	cxt.textAlign = "center";
	cxt.textBaseline = "middle";
	cxt.fillStyle = "black";
	var fix = {x:w/2,y:h/2};
	var position = [];
	var startPosition = {x:w/2, y:h/2 - 5};
	var id = 0;
	position.push(startPosition);
	for(var i = 0; i < 10000; i++){
		console.log(i);
		position.push(getNextPosition2(fix, position[position.length-1], 5));
	}
	for(var i = 0; i < data.length; i++) {
		var fontSize = data[i].value*5;
		cxt.font = fontSize + "px Arial";
		//console.log(i);
		if(i === 0){
			cxt.fillText(data[0].text, fix.x, fix.y);
			continue;
		}
		if(i % 10 == 0)
			id = 0;
		while(1){
			if(!isOverLap(fontSize, cxt.measureText(data[i].text).width, position[id], data[i].text)){
				break;
			}
			id+=Math.floor(1+Math.random()*10);
		}
		cxt.fillText(data[i].text, position[id].x, position[id].y);
		console.log(i+"----"+id);
	}
}
function isOverLap(height, width, position, text){
	var canvas1 = document.getElementsByTagName("canvas")[0];
	var canvas2 = document.getElementsByTagName("canvas")[1];
	var padding = 0;
	var cxt1 = canvas1.getContext("2d");
	var cxt2 = canvas2.getContext("2d");
	var oldData = cxt1.getImageData(position.x - width/2 - padding, position.y - height/2 - padding, width + 2*padding, height + 2*padding);
	cxt2.font = height + "px Arial";
	cxt2.textAlign = "center";
	cxt2.textBaseline = "middle";
	cxt2.fillStyle = "black";
	cxt2.fillText(text, width/2 + padding, height/2 + padding);
	var newData =  cxt2.getImageData(0, 0, width + 2*padding, height + 2*padding);
	cxt2.clearRect(0,0,_w,_h);
	for(var i = 0; i < oldData.data.length; i+=4){
		if(oldData.data[i+3] != 0 && newData.data[i+3] != 0){
			return true;
		}
	}
	return false;
}
function getNextPosition(fix, position, addangle){
	var len = 1;
	var r = Math.sqrt(Math.pow(position.x - fix.x, 2) + Math.pow(position.y - fix.y, 2));
	addangle = (addangle / 360) * 2 * Math.PI;
	var currentangle = Math.atan2(-position.y + fix.y, position.x - fix.x);
	var newangle = currentangle - addangle;
	if(newangle < -1 * Math.PI){
		newangle += 2 * Math.PI;
	}
	var dx = Math.cos(newangle)*(r+len), dy = Math.sin(newangle)*(r+len);
	console.log(newangle + " " + dx + " " + dy);
	return {x:fix.x+dx,y:fix.y-dy};
}
function getNextPosition2(fix, position, len){
	var dx = position.x - fix.x;
	var dy = -position.y + fix.y;
	if(Math.abs(dx) < Math.abs(dy)){
		dx += (dy/Math.abs(dy)) * len;
	}
	else if(Math.abs(dx) === Math.abs(dy)){
		if(dx < 0 && dy > 0){
			dy += len;
		}
		else if(dx > 0 && dy > 0){
			dy -= len;
		}
		else if(dx > 0 && dy < 0){
			dx -= len;
		}
		else{
			dy += len;
		}
	}
	else{
		dy += -(dx/Math.abs(dx)) * len;
	}
	return {x:fix.x + dx, y:fix.y - dy};
}
function transition(){
	var canvas = document.getElementsByTagName("canvas")[0];
	var text = document.getElementsByTagName("textarea")[0].value;
	var data = text2Words(text);
	console.log(data);
	draw(data);
}
function sample(){
	d3.json("word.json", function(json) {
		console.log(json);  //Log output to console
		draw(json);
	});
}
</script>