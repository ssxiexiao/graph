<!DOCTYPE html>
<html>
	<head>
	<meta charset="UTF-8">
		<script type="text/javascript" src="d3.js"></script>
	</head>
	<body>
		<textarea rows="15" cols="80">
		The transformation step is most important, as this is where the mapping happens. D3 provides a structure for applying these transformations, but, as we’ll see, you define the mapping rules. Should larger values make taller bars or brighter circles? Will clusters be sorted on the x-axis by age or category? What color palette is used to fill in countries on your world map? All of the visual design decisions are up to you. You provide the concept, you craft the rules, and D3 executes it—without telling you what to do. (Yes, it’s like the opposite of Excel’s pushy “Chart Wizard.”)
		</textarea>
		<button onclick="transition()">Update</button>
		<button onclick="sample()">Sample</button>
		<input type="radio" name="Layout" value="square" checked="true">squareLayout</input>
		<input type="radio" name="Layout" value="circle">circleLayout</input>
		<canvas></canvas>
		<canvas></canvas>
	</body>
</html>

<script type="text/javascript">
var w = 800;
var h = 800;
var _w = 800;
var _h = 800;
var canvas1 = document.getElementsByTagName("canvas")[0];
var canvas2 = document.getElementsByTagName("canvas")[1];
var cxt1 = canvas1.getContext("2d");
var cxt2 = canvas2.getContext("2d");
var oldData = null;
var oldPix = null;
var newData = null;
var newPix = null;
window.onload = function(){
	canvas1.setAttribute("width", w);
	canvas1.setAttribute("height", h);
	canvas2.setAttribute("width", _w);
	canvas2.setAttribute("height", _h);
	cxt1.textAlign = "center";
	cxt1.textBaseline = "middle";
	cxt1.fillStyle = "black";
	cxt2.textAlign = "center";
	cxt2.textBaseline = "middle";
	cxt2.fillStyle = "black";
}
function hasProperty(arr, name){
	for(var i = 0; i < arr.length; i++){
		if(arr[i].text === name)
			return i;
	}
	return -1;
}
function text2Words(str){
	var words =  str.replace(/[\s|\~|\`|\!|\@|\#|\$|\%|\^|\&|\*|\(|\)|\+|\=|\||\\|\[|\]|\{|\}|\;|\:|\"|\'|\,|\“|\,|\”|‘\<|\.|\>|\/|\—|\?|\t|\n]+/g, " ").split(" ");
	if(words[0] == "")
		words.shift();
	if(words[words.length - 1] == "")
		words.pop();
	var res = [];
	for(var i = 0; i < words.length; i++){
		var id = hasProperty(res, words[i]);
		if(id >= 0){
			res[id].value++;
		}
		else{
			res.push({text:words[i], value:1});
		}
	}
	return res.sort(function(a,b){ return b.value - a.value; });
}
function draw(data){
	var square = document.getElementsByName("Layout")[0];
	cxt1.clearRect(0,0,w,h);
	var fix = {x:w/2,y:h/2};
	var position = {x:w/2, y:h/2 - 5};
	var id = 0;
	var direction = 0;
	if(square.checked === true) {
		var getPosition = getNextPosition2;
	}
	else{
		var getPosition = getNextPosition;
	}
	for(var i = 0; i < data.length; i++) {
		var fontSize = data[i].value*6 + 6;
		cxt1.font = fontSize + "px Impact";
		if(i === 0){
			cxt1.fillText(data[i].text, fix.x, fix.y);
			oldData = cxt1.getImageData(0, 0, w, h);
			oldPix = oldData.data;
			//console.log(i);
		}
		else {
			position = {x: w / 2, y: h / 2 - 5};
			id = 0;
			var width = cxt1.measureText(data[i].text).width;
			while (isOverLap(fontSize, width, position, data[i].text, id)) {
				position = getPosition(fix, position, 5);
				id++;
			}
			cxt1.fillText(data[i].text, position.x, position.y);
			console.log(i);
		}
	}
}
function update(position, imgData){
	for(var i = 0; i < imgData.data.length/4; i++){
		var x = i%imgData.width + position.x - imgData.width/2;
		var y = Math.floor(i/imgData.width) + position.y - imgData.height/2;
		var id = y*oldData.height+x;
		oldPix[id*4+3] += imgData.data[i*4+3];
	}
}
function isOverLap(height, width, position, text, id){
	if(id == 0) {
		if(Math.round(width)%2 != 0){
			var _width = Math.round(width) + 1;
		}
		else{
			var _width = Math.round(width);
		}
		if(Math.round(height)%2 != 0){
			var _height = Math.round(height) + 1;
		}
		else{
			var _height = Math.round(height);
		}
		cxt2.font = height + "px Impact";
		cxt2.fillText(text, _width/2, _height/2);
		newData =  cxt2.getImageData(0, 0, _width, _height);
		newPix = newData.data;
		console.log()
	}
	for(var i = 0; i < newPix.length/4; i++){
		var x = i%newData.width + position.x - newData.width/2;
		var y = Math.floor(i/newData.width) + position.y - newData.height/2;
		var id = y*oldData.height+x;
		if((oldPix[id*4+3]&newPix[i*4+3]) != 0) { return true; }
	}
	update(position, newData);
	cxt2.clearRect(0,0,newData.width,newData.height);
	return false;
}
function getNextPosition(fix, position, addAngle){
	var len = 0;
	var r = Math.sqrt(Math.pow(position.x - fix.x, 2) + Math.pow(position.y - fix.y, 2));
	addAngle = (addAngle / 360) * 2 * Math.PI;
	var currentAngle = Math.atan2(-position.y + fix.y, position.x - fix.x);
	var newAngle = currentAngle - addAngle;
	if(newAngle < -1 * Math.PI){
		newAngle += 2 * Math.PI;
		len = 1;
	}
	if((currentAngle >=　Math.PI * 0.5 && newAngle < Math.PI * 0.5)
		||(currentAngle >= 0 && newAngle < 0)
		||(currentAngle >= Math.PI * -0.5 && newAngle < Math.PI * -0.5)){
		len = 1;
	}
	var dx = Math.cos(newAngle)*(r+len), dy = Math.sin(newAngle)*(r+len);
	return {x:Math.floor(fix.x+dx),y:Math.floor(fix.y-dy)};
}
function getNextPosition2(fix, position, len){
	var dx = position.x - fix.x;
	var dy = -position.y + fix.y;
	if(Math.abs(dx) < Math.abs(dy)){
		dx += (dy/Math.abs(dy)) * len;
	}
	else if(Math.abs(dx) === Math.abs(dy)){
		if(dx < 0 && dy > 0){
			dy += len;
		}
		else if(dx > 0 && dy > 0){
			dy -= len;
		}
		else if(dx > 0 && dy < 0){
			dx -= len;
		}
		else{
			dy += len;
		}
	}
	else{
		dy += -(dx/Math.abs(dx)) * len;
	}
	return {x:fix.x + dx, y:fix.y - dy};
}
function transition(){
	var canvas = document.getElementsByTagName("canvas")[0];
	var text = document.getElementsByTagName("textarea")[0].value;
	var data = text2Words(text);
	//console.log(data);
	draw(data);
}
function sample(){
	d3.json("word.json", function(json) {
		if(json != null) {
			draw(json);
		}
	});
}
</script>